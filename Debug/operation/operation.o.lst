   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,6
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "operation.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
  18              	 .align 2
  19              	 .code 16
  20              	 .thumb_func
  22              	XMC_GPIO_GetInput:
  23              	.LFB52:
  24              	 .file 1 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_gpio.h"
   1:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
   2:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @date 2015-06-20
   4:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   5:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @cond
   6:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
   7:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMClib v2.1.24 - XMC Peripheral Driver Library 
   8:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
   9:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Copyright (c) 2015-2019, Infineon Technologies AG
  10:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * All rights reserved.                        
  11:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                             
  12:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * following conditions are met:   
  14:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  15:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer.                        
  17:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  18:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  21:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  24:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *                                                                              
  32:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  35:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  36:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Change History
  37:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * --------------
  38:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  39:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-02-20:
  40:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Initial draft<br>
  41:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Documentation improved <br>
  42:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *      
  43:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * 2015-06-20:
  44:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  45:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  46:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @endcond
  47:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  48:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  49:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  50:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  51:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_H
  52:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  53:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  54:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * HEADER FILES
  55:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  56:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  57:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc_common.h"
  58:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  59:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  60:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  61:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @{
  62:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  63:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  64:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
  65:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @addtogroup GPIO
  66:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  67:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  68:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  69:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  70:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics. 
  71:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  72:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  73:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  74:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Input mode features:
  75:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  76:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  77:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
  78:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  79:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  80:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  81:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * 
  82:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Output mode features:
  83:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  84:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
  85:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  86:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
  87:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  88:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  89:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
  90:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *@{
  91:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
  92:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  
  93:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
  94:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * MACROS
  95:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
  96:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
  97:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
  98:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
  99:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 100:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 101:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 											
 102:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 103:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 104:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 105:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 106:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 107:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 108:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))                    
 109:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****                                             
 110:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 111:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * ENUMS
 112:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 113:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 114:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 115:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 116:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 117:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 118:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 119:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 120:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 121:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 122:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 123:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 124:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 125:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 126:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 127:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 128:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 129:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 130:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 131:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 132:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 133:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 134:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 135:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 136:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 137:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 138:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  #if UC_FAMILY == XMC1
 139:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 140:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 141:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 142:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #else
 143:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 144:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 145:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 146:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**************************************************************************************************
 147:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * API PROTOTYPES
 148:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  **************************************************************************************************
 149:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 150:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #ifdef __cplusplus
 151:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** extern "C" {
 152:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** #endif
 153:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 154:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 155:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 156:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 157:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 158:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 159:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 160:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 161:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 162:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 163:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC1
 164:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 165:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 166:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 167:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 168:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \if XMC4
 169:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 170:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 171:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 172:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \endif
 173:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 174:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 175:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 176:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 177:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 178:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 179:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 180:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 181:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 182:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 183:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 184:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  
 185:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 186:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  
 187:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 188:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 189:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 190:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 191:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 192:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 193:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 194:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 195:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 196:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 197:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 198:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 199:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 200:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 201:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  None
 202:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 203:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 204:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 205:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 206:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 207:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 208:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 209:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 210:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 211:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 212:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 213:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 214:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 215:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 216:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 217:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 218:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 219:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 220:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 221:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 222:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 223:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 224:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 225:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 226:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 227:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 228:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 229:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 230:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 231:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 232:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 233:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   
 234:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 235:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** }
 236:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 237:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 238:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 239:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 240:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 241:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 242:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 243:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 244:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 245:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 246:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 247:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 248:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 249:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 250:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 251:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 252:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 253:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 254:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 255:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 256:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 257:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 258:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 259:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 260:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
 261:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** }
 262:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 263:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 264:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 265:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 266:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param  pin	port pin number.
 267:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 268:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return  None
 269:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 270:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 271:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 272:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 273:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 274:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 275:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 276:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 277:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 278:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 279:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 280:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 281:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 282:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 283:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 284:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 285:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 286:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
 287:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** }
 288:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 289:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 290:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 291:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 292:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  port pin number.
 293:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 294:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return None
 295:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 296:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 297:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 298:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 299:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 300:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 301:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 302:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 303:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 304:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 305:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 306:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 307:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 308:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 309:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
 310:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 311:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 312:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
 313:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** }
 314:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 315:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** /**
 316:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 317:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 318:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @param pin  Port pin number.
 319:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 320:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 321:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 322:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 323:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 324:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 325:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 326:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * None
 327:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 328:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 329:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 330:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  *
 331:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****  */
 332:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 333:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 334:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** {
  25              	 .loc 1 334 0
  26              	 .cfi_startproc
  27 0000 80B5     	 push {r7,lr}
  28              	.LCFI0:
  29              	 .cfi_def_cfa_offset 8
  30              	 .cfi_offset 7,-8
  31              	 .cfi_offset 14,-4
  32 0002 82B0     	 sub sp,sp,#8
  33              	.LCFI1:
  34              	 .cfi_def_cfa_offset 16
  35 0004 00AF     	 add r7,sp,#0
  36              	.LCFI2:
  37              	 .cfi_def_cfa_register 7
  38 0006 7860     	 str r0,[r7,#4]
  39 0008 0A1C     	 mov r2,r1
  40 000a FB1C     	 add r3,r7,#3
  41 000c 1A70     	 strb r2,[r3]
 335:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 336:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** 
 337:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
  42              	 .loc 1 337 0
  43 000e 7B68     	 ldr r3,[r7,#4]
  44 0010 5A6A     	 ldr r2,[r3,#36]
  45 0012 FB1C     	 add r3,r7,#3
  46 0014 1B78     	 ldrb r3,[r3]
  47 0016 DA40     	 lsr r2,r2,r3
  48 0018 131C     	 mov r3,r2
  49 001a 0122     	 mov r2,#1
  50 001c 1340     	 and r3,r2
 338:C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc\xmc_gpio.h **** }
  51              	 .loc 1 338 0
  52 001e 181C     	 mov r0,r3
  53 0020 BD46     	 mov sp,r7
  54 0022 02B0     	 add sp,sp,#8
  55              	 
  56 0024 80BD     	 pop {r7,pc}
  57              	 .cfi_endproc
  58              	.LFE52:
  60              	 .comm tx_config,8,4
  61              	 .comm rx_config,8,4
  62              	 .comm uart_config,12,4
  63              	 .comm pcs_button_config,8,4
  64              	 .comm CAN0_txd_config,8,4
  65              	 .comm CAN0_rxd_config,8,4
  66              	 .comm can_baud,12,4
  67              	 .comm msgObjToPCS,32,8
  68              	 .comm msgObjFromPCS,32,8
  69              	 .comm tx_genix_config,8,4
  70              	 .comm rx_genix_config,8,4
  71              	 .comm uart_genix_config,12,4
  72              	 .comm led,8,4
  73              	 .comm button,8,4
  74              	 .comm dipswitch_config,8,4
  75              	 .comm g_global_handle,24,4
  76              	 .comm g_group_handle,20,4
  77              	 .comm g_queue_handle,12,4
  78              	 .comm g_queue_entry,16,4
  79              	 .comm g_channel_handle,64,4
  80              	 .comm g_result_handle,16,4
  81              	 .comm adc_io,8,4
  82              	 .comm relay_KMP,8,4
  83              	 .comm relay_KMF,8,4
  84              	 .comm relay_KDSG,8,4
  85              	 .comm relay_KBAT,8,4
  86              	 .comm SLICE0_config,8,4
  87              	 .comm SLICE1_config,8,4
  88              	 .comm SLICE2_config,8,4
  89              	 .comm sysTickParamHandle,6,4
  90              	 .comm pcsBmsStatus,4,4
  91              	 .comm bmsSensor,8,4
  92              	 .comm pcsVoltages,8,4
  93              	 .comm pcsCurrents,8,4
  94              	 .comm pcsPowers,8,4
  95              	 .comm pcsMiscs,4,4
  96              	 .comm pcsSystemStatus,5,4
  97              	 .comm pcsDCgridStatus,4,4
  98              	 .comm pcsACinvStatus,4,4
  99              	 .comm pcsPVconvStatus,4,4
 100              	 .comm pcsBatconvStatus,4,4
 101              	 .comm data_group,80,4
 102              	 .comm buffptr,4,4
 103              	 .comm espBuffer,80,4
 104              	 .comm pduSensorRaw,8,4
 105              	 .comm pduSensorAvg,20,4
 106              	 .comm pduSensor,16,4
 107              	 .comm genix_data,8,4
 108              	 .comm mcu_state,1,1
 109              	 .comm controlFlag,6,4
 110              	 .global __aeabi_fcmpgt
 111              	 .global __aeabi_fcmplt
 112 0026 C046     	 .section .text.OP_SetupConnection,"ax",%progbits
 113              	 .align 2
 114              	 .global OP_SetupConnection
 115              	 .code 16
 116              	 .thumb_func
 118              	OP_SetupConnection:
 119              	.LFB380:
 120              	 .file 2 "../operation/operation.c"
   1:../operation/operation.c **** /*
   2:../operation/operation.c ****  * operation.c
   3:../operation/operation.c ****  *
   4:../operation/operation.c ****  *  Created on: Mar 3, 2022
   5:../operation/operation.c ****  *      Author: Lenovo
   6:../operation/operation.c ****  */
   7:../operation/operation.c **** 
   8:../operation/operation.c **** #include "operation.h"
   9:../operation/operation.c **** 
  10:../operation/operation.c **** OP_STATE_t mcu_state;
  11:../operation/operation.c **** OP_CTRL_FLAG_t controlFlag;
  12:../operation/operation.c **** 
  13:../operation/operation.c **** 
  14:../operation/operation.c **** void OP_SetupConnection(OP_STATE_t *state, MISC_SYSTICK_PARAM_t *sysTickParam,
  15:../operation/operation.c **** 						OP_CTRL_FLAG_t *ctrlFlag, float pvVoltage, PCS_BMC_STATUS_t *pcsBmsStatus, PCS_STATUS_t *pcsS
  16:../operation/operation.c **** {
 121              	 .loc 2 16 0
 122              	 .cfi_startproc
 123 0000 80B5     	 push {r7,lr}
 124              	.LCFI3:
 125              	 .cfi_def_cfa_offset 8
 126              	 .cfi_offset 7,-8
 127              	 .cfi_offset 14,-4
 128 0002 84B0     	 sub sp,sp,#16
 129              	.LCFI4:
 130              	 .cfi_def_cfa_offset 24
 131 0004 00AF     	 add r7,sp,#0
 132              	.LCFI5:
 133              	 .cfi_def_cfa_register 7
 134 0006 F860     	 str r0,[r7,#12]
 135 0008 B960     	 str r1,[r7,#8]
 136 000a 7A60     	 str r2,[r7,#4]
 137 000c 3B60     	 str r3,[r7]
  17:../operation/operation.c **** 	static bool toggle_timer = false;
  18:../operation/operation.c **** 	/* 1. Ensure all relay at initial state */
  19:../operation/operation.c **** 	/* Initiate relay status */
  20:../operation/operation.c **** 	PDU_Switch_Relay(PDU_RELAY_KBAT, PDU_RELAY_OPEN);
 138              	 .loc 2 20 0
 139 000e 0020     	 mov r0,#0
 140 0010 0021     	 mov r1,#0
 141 0012 FFF7FEFF 	 bl PDU_Switch_Relay
  21:../operation/operation.c **** 	PDU_Switch_Relay(PDU_RELAY_KDSG, PDU_RELAY_OPEN);
 142              	 .loc 2 21 0
 143 0016 0320     	 mov r0,#3
 144 0018 0021     	 mov r1,#0
 145 001a FFF7FEFF 	 bl PDU_Switch_Relay
  22:../operation/operation.c **** 	PDU_Switch_Relay(PDU_RELAY_KMP,  PDU_RELAY_OPEN);
 146              	 .loc 2 22 0
 147 001e 0120     	 mov r0,#1
 148 0020 0021     	 mov r1,#0
 149 0022 FFF7FEFF 	 bl PDU_Switch_Relay
  23:../operation/operation.c **** 	PDU_Switch_Relay(PDU_RELAY_KMF,  PDU_RELAY_OPEN);
 150              	 .loc 2 23 0
 151 0026 0220     	 mov r0,#2
 152 0028 0021     	 mov r1,#0
 153 002a FFF7FEFF 	 bl PDU_Switch_Relay
  24:../operation/operation.c **** 
  25:../operation/operation.c **** 	/* CAN Status Setup */
  26:../operation/operation.c **** 	pcsBmsStatus->bmc_main_relay		= RELAY_OPEN;
 154              	 .loc 2 26 0
 155 002e BB69     	 ldr r3,[r7,#24]
 156 0030 0022     	 mov r2,#0
 157 0032 9A70     	 strb r2,[r3,#2]
  27:../operation/operation.c **** 	pcsBmsStatus->bmc_precharge_relay	= RELAY_OPEN;
 158              	 .loc 2 27 0
 159 0034 BB69     	 ldr r3,[r7,#24]
 160 0036 0022     	 mov r2,#0
 161 0038 DA70     	 strb r2,[r3,#3]
  28:../operation/operation.c **** 	pcsBmsStatus->bmc_status			= BMU_PRECHARGE;
 162              	 .loc 2 28 0
 163 003a BB69     	 ldr r3,[r7,#24]
 164 003c 0122     	 mov r2,#1
 165 003e 1A70     	 strb r2,[r3]
  29:../operation/operation.c **** 	pcsBmsStatus->bmc_pcs_command		= BMU_PCS_STOP;
 166              	 .loc 2 29 0
 167 0040 BB69     	 ldr r3,[r7,#24]
 168 0042 0022     	 mov r2,#0
 169 0044 5A70     	 strb r2,[r3,#1]
  30:../operation/operation.c **** 
  31:../operation/operation.c **** 	/* 2. Checking PV Condition */
  32:../operation/operation.c **** 	if((pvVoltage > 150.0 || ctrlFlag->isBypass_power_mode))
 170              	 .loc 2 32 0
 171 0046 3868     	 ldr r0,[r7]
 172 0048 2E49     	 ldr r1,.L10
 173 004a FFF7FEFF 	 bl __aeabi_fcmpgt
 174 004e 031E     	 sub r3,r0,#0
 175 0050 03D1     	 bne .L4
 176              	 .loc 2 32 0 is_stmt 0 discriminator 1
 177 0052 7B68     	 ldr r3,[r7,#4]
 178 0054 DB78     	 ldrb r3,[r3,#3]
 179 0056 002B     	 cmp r3,#0
 180 0058 38D0     	 beq .L5
 181              	.L4:
  33:../operation/operation.c **** 	{
  34:../operation/operation.c **** 		if((!sysTickParam->isTimeOut) && !toggle_timer) // start timer
 182              	 .loc 2 34 0 is_stmt 1
 183 005a BB68     	 ldr r3,[r7,#8]
 184 005c 1B79     	 ldrb r3,[r3,#4]
 185 005e 0122     	 mov r2,#1
 186 0060 5340     	 eor r3,r2
 187 0062 DBB2     	 uxtb r3,r3
 188 0064 002B     	 cmp r3,#0
 189 0066 10D0     	 beq .L6
 190              	 .loc 2 34 0 is_stmt 0 discriminator 1
 191 0068 274B     	 ldr r3,.L10+4
 192 006a 1B78     	 ldrb r3,[r3]
 193 006c 0122     	 mov r2,#1
 194 006e 5340     	 eor r3,r2
 195 0070 DBB2     	 uxtb r3,r3
 196 0072 002B     	 cmp r3,#0
 197 0074 09D0     	 beq .L6
  35:../operation/operation.c **** 		{
  36:../operation/operation.c **** 			toggle_timer = true;
 198              	 .loc 2 36 0 is_stmt 1
 199 0076 244B     	 ldr r3,.L10+4
 200 0078 0122     	 mov r2,#1
 201 007a 1A70     	 strb r2,[r3]
  37:../operation/operation.c **** 			sysTickParam->enable	= true;
 202              	 .loc 2 37 0
 203 007c BB68     	 ldr r3,[r7,#8]
 204 007e 0122     	 mov r2,#1
 205 0080 1A70     	 strb r2,[r3]
  38:../operation/operation.c **** 			sysTickParam->count		= 15;
 206              	 .loc 2 38 0
 207 0082 BB68     	 ldr r3,[r7,#8]
 208 0084 0F22     	 mov r2,#15
 209 0086 5A80     	 strh r2,[r3,#2]
 210 0088 1FE0     	 b .L7
 211              	.L6:
  39:../operation/operation.c **** 		}
  40:../operation/operation.c **** 		else if((sysTickParam->isTimeOut) && toggle_timer)
 212              	 .loc 2 40 0
 213 008a BB68     	 ldr r3,[r7,#8]
 214 008c 1B79     	 ldrb r3,[r3,#4]
 215 008e 002B     	 cmp r3,#0
 216 0090 1BD0     	 beq .L7
 217              	 .loc 2 40 0 is_stmt 0 discriminator 1
 218 0092 1D4B     	 ldr r3,.L10+4
 219 0094 1B78     	 ldrb r3,[r3]
 220 0096 002B     	 cmp r3,#0
 221 0098 17D0     	 beq .L7
  41:../operation/operation.c **** 		{
  42:../operation/operation.c **** 			toggle_timer = false;
 222              	 .loc 2 42 0 is_stmt 1
 223 009a 1B4B     	 ldr r3,.L10+4
 224 009c 0022     	 mov r2,#0
 225 009e 1A70     	 strb r2,[r3]
  43:../operation/operation.c **** 			sysTickParam->isTimeOut	= false;
 226              	 .loc 2 43 0
 227 00a0 BB68     	 ldr r3,[r7,#8]
 228 00a2 0022     	 mov r2,#0
 229 00a4 1A71     	 strb r2,[r3,#4]
  44:../operation/operation.c **** 			sysTickParam->count		= 0;
 230              	 .loc 2 44 0
 231 00a6 BB68     	 ldr r3,[r7,#8]
 232 00a8 0022     	 mov r2,#0
 233 00aa 5A80     	 strh r2,[r3,#2]
  45:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KMF,  PDU_RELAY_CLOSE);
 234              	 .loc 2 45 0
 235 00ac 0220     	 mov r0,#2
 236 00ae 0121     	 mov r1,#1
 237 00b0 FFF7FEFF 	 bl PDU_Switch_Relay
  46:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KDSG, PDU_RELAY_CLOSE);
 238              	 .loc 2 46 0
 239 00b4 0320     	 mov r0,#3
 240 00b6 0121     	 mov r1,#1
 241 00b8 FFF7FEFF 	 bl PDU_Switch_Relay
  47:../operation/operation.c **** 			pcsBmsStatus->bmc_precharge_relay = RELAY_CLOSE;
 242              	 .loc 2 47 0
 243 00bc BB69     	 ldr r3,[r7,#24]
 244 00be 0122     	 mov r2,#1
 245 00c0 DA70     	 strb r2,[r3,#3]
  48:../operation/operation.c **** 			*state	= OP_TURN_ON;
 246              	 .loc 2 48 0
 247 00c2 FB68     	 ldr r3,[r7,#12]
 248 00c4 0122     	 mov r2,#1
 249 00c6 1A70     	 strb r2,[r3]
  34:../operation/operation.c **** 		{
 250              	 .loc 2 34 0
 251 00c8 19E0     	 b .L3
 252              	.L7:
 253 00ca 18E0     	 b .L3
 254              	.L5:
  49:../operation/operation.c **** 		}
  50:../operation/operation.c **** 	}
  51:../operation/operation.c **** 	else if((pvVoltage < 150.0 || !ctrlFlag->isBypass_power_mode))
 255              	 .loc 2 51 0
 256 00cc 3868     	 ldr r0,[r7]
 257 00ce 0D49     	 ldr r1,.L10
 258 00d0 FFF7FEFF 	 bl __aeabi_fcmplt
 259 00d4 031E     	 sub r3,r0,#0
 260 00d6 06D1     	 bne .L9
 261              	 .loc 2 51 0 is_stmt 0 discriminator 1
 262 00d8 7B68     	 ldr r3,[r7,#4]
 263 00da DB78     	 ldrb r3,[r3,#3]
 264 00dc 0122     	 mov r2,#1
 265 00de 5340     	 eor r3,r2
 266 00e0 DBB2     	 uxtb r3,r3
 267 00e2 002B     	 cmp r3,#0
 268 00e4 0BD0     	 beq .L3
 269              	.L9:
  52:../operation/operation.c **** 	{
  53:../operation/operation.c **** 		toggle_timer = false;
 270              	 .loc 2 53 0 is_stmt 1
 271 00e6 084B     	 ldr r3,.L10+4
 272 00e8 0022     	 mov r2,#0
 273 00ea 1A70     	 strb r2,[r3]
  54:../operation/operation.c **** 		sysTickParam->enable	= false;
 274              	 .loc 2 54 0
 275 00ec BB68     	 ldr r3,[r7,#8]
 276 00ee 0022     	 mov r2,#0
 277 00f0 1A70     	 strb r2,[r3]
  55:../operation/operation.c **** 		sysTickParam->isTimeOut	= false;
 278              	 .loc 2 55 0
 279 00f2 BB68     	 ldr r3,[r7,#8]
 280 00f4 0022     	 mov r2,#0
 281 00f6 1A71     	 strb r2,[r3,#4]
  56:../operation/operation.c **** 		sysTickParam->count		= 0;
 282              	 .loc 2 56 0
 283 00f8 BB68     	 ldr r3,[r7,#8]
 284 00fa 0022     	 mov r2,#0
 285 00fc 5A80     	 strh r2,[r3,#2]
 286              	.L3:
  57:../operation/operation.c **** 	}
  58:../operation/operation.c **** }
 287              	 .loc 2 58 0
 288 00fe BD46     	 mov sp,r7
 289 0100 04B0     	 add sp,sp,#16
 290              	 
 291 0102 80BD     	 pop {r7,pc}
 292              	.L11:
 293              	 .align 2
 294              	.L10:
 295 0104 00001643 	 .word 1125515264
 296 0108 00000000 	 .word toggle_timer.10959
 297              	 .cfi_endproc
 298              	.LFE380:
 300              	 .section .text.OP_TurnOnPCS,"ax",%progbits
 301              	 .align 2
 302              	 .global OP_TurnOnPCS
 303              	 .code 16
 304              	 .thumb_func
 306              	OP_TurnOnPCS:
 307              	.LFB381:
  59:../operation/operation.c **** 
  60:../operation/operation.c **** void OP_TurnOnPCS(OP_STATE_t *state, MISC_SYSTICK_PARAM_t *sysTickParam,
  61:../operation/operation.c **** 		OP_CTRL_FLAG_t *ctrlFlag, PCS_BMC_STATUS_t *pcsBmsStatus, PCS_STATUS_t *pcsStatus)
  62:../operation/operation.c **** {
 308              	 .loc 2 62 0
 309              	 .cfi_startproc
 310 0000 80B5     	 push {r7,lr}
 311              	.LCFI6:
 312              	 .cfi_def_cfa_offset 8
 313              	 .cfi_offset 7,-8
 314              	 .cfi_offset 14,-4
 315 0002 84B0     	 sub sp,sp,#16
 316              	.LCFI7:
 317              	 .cfi_def_cfa_offset 24
 318 0004 00AF     	 add r7,sp,#0
 319              	.LCFI8:
 320              	 .cfi_def_cfa_register 7
 321 0006 F860     	 str r0,[r7,#12]
 322 0008 B960     	 str r1,[r7,#8]
 323 000a 7A60     	 str r2,[r7,#4]
 324 000c 3B60     	 str r3,[r7]
  63:../operation/operation.c **** 	static bool toggle_timer = false;
  64:../operation/operation.c **** 	static bool isPrechargeExecuted = false;
  65:../operation/operation.c **** 
  66:../operation/operation.c **** 	if(!XMC_GPIO_GetInput(P2_2) && !isPrechargeExecuted && (pcsStatus->pcs_system_status == PCS_STAT_S
 325              	 .loc 2 66 0
 326 000e 514B     	 ldr r3,.L19
 327 0010 181C     	 mov r0,r3
 328 0012 0221     	 mov r1,#2
 329 0014 FFF7FEFF 	 bl XMC_GPIO_GetInput
 330 0018 031E     	 sub r3,r0,#0
 331 001a 42D1     	 bne .L13
 332              	 .loc 2 66 0 is_stmt 0 discriminator 1
 333 001c 4E4B     	 ldr r3,.L19+4
 334 001e 1B78     	 ldrb r3,[r3]
 335 0020 0122     	 mov r2,#1
 336 0022 5340     	 eor r3,r2
 337 0024 DBB2     	 uxtb r3,r3
 338 0026 002B     	 cmp r3,#0
 339 0028 3BD0     	 beq .L13
 340              	 .loc 2 66 0 discriminator 2
 341 002a BB69     	 ldr r3,[r7,#24]
 342 002c 1B78     	 ldrb r3,[r3]
 343 002e 042B     	 cmp r3,#4
 344 0030 37D1     	 bne .L13
  67:../operation/operation.c **** 	{
  68:../operation/operation.c **** 		if((!sysTickParam->isTimeOut) && (!sysTickParam->enable) && !toggle_timer)
 345              	 .loc 2 68 0 is_stmt 1
 346 0032 BB68     	 ldr r3,[r7,#8]
 347 0034 1B79     	 ldrb r3,[r3,#4]
 348 0036 0122     	 mov r2,#1
 349 0038 5340     	 eor r3,r2
 350 003a DBB2     	 uxtb r3,r3
 351 003c 002B     	 cmp r3,#0
 352 003e 17D0     	 beq .L14
 353              	 .loc 2 68 0 is_stmt 0 discriminator 1
 354 0040 BB68     	 ldr r3,[r7,#8]
 355 0042 1B78     	 ldrb r3,[r3]
 356 0044 0122     	 mov r2,#1
 357 0046 5340     	 eor r3,r2
 358 0048 DBB2     	 uxtb r3,r3
 359 004a 002B     	 cmp r3,#0
 360 004c 10D0     	 beq .L14
 361              	 .loc 2 68 0 discriminator 2
 362 004e 434B     	 ldr r3,.L19+8
 363 0050 1B78     	 ldrb r3,[r3]
 364 0052 0122     	 mov r2,#1
 365 0054 5340     	 eor r3,r2
 366 0056 DBB2     	 uxtb r3,r3
 367 0058 002B     	 cmp r3,#0
 368 005a 09D0     	 beq .L14
  69:../operation/operation.c **** 		{
  70:../operation/operation.c **** 			toggle_timer			= true;
 369              	 .loc 2 70 0 is_stmt 1
 370 005c 3F4B     	 ldr r3,.L19+8
 371 005e 0122     	 mov r2,#1
 372 0060 1A70     	 strb r2,[r3]
  71:../operation/operation.c **** 			sysTickParam->enable	= true;
 373              	 .loc 2 71 0
 374 0062 BB68     	 ldr r3,[r7,#8]
 375 0064 0122     	 mov r2,#1
 376 0066 1A70     	 strb r2,[r3]
  72:../operation/operation.c **** 			sysTickParam->count		= 2;
 377              	 .loc 2 72 0
 378 0068 BB68     	 ldr r3,[r7,#8]
 379 006a 0222     	 mov r2,#2
 380 006c 5A80     	 strh r2,[r3,#2]
 381 006e 17E0     	 b .L15
 382              	.L14:
  73:../operation/operation.c **** 		}
  74:../operation/operation.c **** 		else if ((sysTickParam->isTimeOut) && (!sysTickParam->enable))
 383              	 .loc 2 74 0
 384 0070 BB68     	 ldr r3,[r7,#8]
 385 0072 1B79     	 ldrb r3,[r3,#4]
 386 0074 002B     	 cmp r3,#0
 387 0076 13D0     	 beq .L15
 388              	 .loc 2 74 0 is_stmt 0 discriminator 1
 389 0078 BB68     	 ldr r3,[r7,#8]
 390 007a 1B78     	 ldrb r3,[r3]
 391 007c 0122     	 mov r2,#1
 392 007e 5340     	 eor r3,r2
 393 0080 DBB2     	 uxtb r3,r3
 394 0082 002B     	 cmp r3,#0
 395 0084 0CD0     	 beq .L15
  75:../operation/operation.c **** 		{
  76:../operation/operation.c **** 			ctrlFlag->isPerforming_Precharge = true;
 396              	 .loc 2 76 0 is_stmt 1
 397 0086 7B68     	 ldr r3,[r7,#4]
 398 0088 0122     	 mov r2,#1
 399 008a 1A70     	 strb r2,[r3]
  77:../operation/operation.c **** 			toggle_timer			= false;
 400              	 .loc 2 77 0
 401 008c 334B     	 ldr r3,.L19+8
 402 008e 0022     	 mov r2,#0
 403 0090 1A70     	 strb r2,[r3]
  78:../operation/operation.c **** 			sysTickParam->isTimeOut = false;
 404              	 .loc 2 78 0
 405 0092 BB68     	 ldr r3,[r7,#8]
 406 0094 0022     	 mov r2,#0
 407 0096 1A71     	 strb r2,[r3,#4]
  79:../operation/operation.c **** 			sysTickParam->count		= 0;
 408              	 .loc 2 79 0
 409 0098 BB68     	 ldr r3,[r7,#8]
 410 009a 0022     	 mov r2,#0
 411 009c 5A80     	 strh r2,[r3,#2]
  68:../operation/operation.c **** 		{
 412              	 .loc 2 68 0
 413 009e 17E0     	 b .L16
 414              	.L15:
 415 00a0 16E0     	 b .L16
 416              	.L13:
  80:../operation/operation.c **** 		}
  81:../operation/operation.c **** 	}
  82:../operation/operation.c **** 	else if(XMC_GPIO_GetInput(P2_2) && !isPrechargeExecuted)
 417              	 .loc 2 82 0
 418 00a2 2C4B     	 ldr r3,.L19
 419 00a4 181C     	 mov r0,r3
 420 00a6 0221     	 mov r1,#2
 421 00a8 FFF7FEFF 	 bl XMC_GPIO_GetInput
 422 00ac 031E     	 sub r3,r0,#0
 423 00ae 0FD0     	 beq .L16
 424              	 .loc 2 82 0 is_stmt 0 discriminator 1
 425 00b0 294B     	 ldr r3,.L19+4
 426 00b2 1B78     	 ldrb r3,[r3]
 427 00b4 0122     	 mov r2,#1
 428 00b6 5340     	 eor r3,r2
 429 00b8 DBB2     	 uxtb r3,r3
 430 00ba 002B     	 cmp r3,#0
 431 00bc 08D0     	 beq .L16
  83:../operation/operation.c **** 	{
  84:../operation/operation.c **** 		toggle_timer			= false;
 432              	 .loc 2 84 0 is_stmt 1
 433 00be 274B     	 ldr r3,.L19+8
 434 00c0 0022     	 mov r2,#0
 435 00c2 1A70     	 strb r2,[r3]
  85:../operation/operation.c **** 		sysTickParam->enable 	= false;
 436              	 .loc 2 85 0
 437 00c4 BB68     	 ldr r3,[r7,#8]
 438 00c6 0022     	 mov r2,#0
 439 00c8 1A70     	 strb r2,[r3]
  86:../operation/operation.c **** 		sysTickParam->count 	= 0;
 440              	 .loc 2 86 0
 441 00ca BB68     	 ldr r3,[r7,#8]
 442 00cc 0022     	 mov r2,#0
 443 00ce 5A80     	 strh r2,[r3,#2]
 444              	.L16:
  87:../operation/operation.c **** 	}
  88:../operation/operation.c **** 
  89:../operation/operation.c **** 	if(ctrlFlag->isPerforming_Precharge)
 445              	 .loc 2 89 0
 446 00d0 7B68     	 ldr r3,[r7,#4]
 447 00d2 1B78     	 ldrb r3,[r3]
 448 00d4 002B     	 cmp r3,#0
 449 00d6 3AD0     	 beq .L12
  90:../operation/operation.c **** 	{
  91:../operation/operation.c **** 		if(!isPrechargeExecuted)
 450              	 .loc 2 91 0
 451 00d8 1F4B     	 ldr r3,.L19+4
 452 00da 1B78     	 ldrb r3,[r3]
 453 00dc 0122     	 mov r2,#1
 454 00de 5340     	 eor r3,r2
 455 00e0 DBB2     	 uxtb r3,r3
 456 00e2 002B     	 cmp r3,#0
 457 00e4 0ED0     	 beq .L18
  92:../operation/operation.c **** 		{
  93:../operation/operation.c **** 			pcsBmsStatus->bmc_main_relay 		= RELAY_OPEN;
 458              	 .loc 2 93 0
 459 00e6 3B68     	 ldr r3,[r7]
 460 00e8 0022     	 mov r2,#0
 461 00ea 9A70     	 strb r2,[r3,#2]
  94:../operation/operation.c **** 			pcsBmsStatus->bmc_precharge_relay	= RELAY_CLOSE;
 462              	 .loc 2 94 0
 463 00ec 3B68     	 ldr r3,[r7]
 464 00ee 0122     	 mov r2,#1
 465 00f0 DA70     	 strb r2,[r3,#3]
  95:../operation/operation.c **** 			pcsBmsStatus->bmc_status			= BMU_PRECHARGE;
 466              	 .loc 2 95 0
 467 00f2 3B68     	 ldr r3,[r7]
 468 00f4 0122     	 mov r2,#1
 469 00f6 1A70     	 strb r2,[r3]
  96:../operation/operation.c **** 			pcsBmsStatus->bmc_pcs_command		= BMU_PCS_STOP;
 470              	 .loc 2 96 0
 471 00f8 3B68     	 ldr r3,[r7]
 472 00fa 0022     	 mov r2,#0
 473 00fc 5A70     	 strb r2,[r3,#1]
  97:../operation/operation.c **** 			isPrechargeExecuted					= true;
 474              	 .loc 2 97 0
 475 00fe 164B     	 ldr r3,.L19+4
 476 0100 0122     	 mov r2,#1
 477 0102 1A70     	 strb r2,[r3]
 478              	.L18:
  98:../operation/operation.c **** 		}
  99:../operation/operation.c **** 
 100:../operation/operation.c **** 		if(pcsStatus->pcs_precharge_IsComplete)
 479              	 .loc 2 100 0
 480 0104 BB69     	 ldr r3,[r7,#24]
 481 0106 5B78     	 ldrb r3,[r3,#1]
 482 0108 002B     	 cmp r3,#0
 483 010a 20D0     	 beq .L12
 101:../operation/operation.c **** 		{
 102:../operation/operation.c **** 			/* CLose Main Relay */
 103:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KMP, PDU_RELAY_CLOSE);
 484              	 .loc 2 103 0
 485 010c 0120     	 mov r0,#1
 486 010e 0121     	 mov r1,#1
 487 0110 FFF7FEFF 	 bl PDU_Switch_Relay
 104:../operation/operation.c **** 
 105:../operation/operation.c **** 			/* Open Predischarge Relay */
 106:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KDSG, PDU_RELAY_OPEN);
 488              	 .loc 2 106 0
 489 0114 0320     	 mov r0,#3
 490 0116 0021     	 mov r1,#0
 491 0118 FFF7FEFF 	 bl PDU_Switch_Relay
 107:../operation/operation.c **** 
 108:../operation/operation.c **** 			pcsBmsStatus->bmc_main_relay		= RELAY_CLOSE;
 492              	 .loc 2 108 0
 493 011c 3B68     	 ldr r3,[r7]
 494 011e 0122     	 mov r2,#1
 495 0120 9A70     	 strb r2,[r3,#2]
 109:../operation/operation.c **** 			pcsBmsStatus->bmc_precharge_relay	= RELAY_OPEN;
 496              	 .loc 2 109 0
 497 0122 3B68     	 ldr r3,[r7]
 498 0124 0022     	 mov r2,#0
 499 0126 DA70     	 strb r2,[r3,#3]
 110:../operation/operation.c **** 			pcsBmsStatus->bmc_status			= BMU_RUNNING;
 500              	 .loc 2 110 0
 501 0128 3B68     	 ldr r3,[r7]
 502 012a 0222     	 mov r2,#2
 503 012c 1A70     	 strb r2,[r3]
 111:../operation/operation.c **** 			pcsBmsStatus->bmc_pcs_command		= BMU_PCS_START;
 504              	 .loc 2 111 0
 505 012e 3B68     	 ldr r3,[r7]
 506 0130 0122     	 mov r2,#1
 507 0132 5A70     	 strb r2,[r3,#1]
 112:../operation/operation.c **** 
 113:../operation/operation.c **** 			*state = OP_RUNNING;
 508              	 .loc 2 113 0
 509 0134 FB68     	 ldr r3,[r7,#12]
 510 0136 0222     	 mov r2,#2
 511 0138 1A70     	 strb r2,[r3]
 114:../operation/operation.c **** 
 115:../operation/operation.c **** 			/* close battery relay */
 116:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KBAT, PDU_RELAY_CLOSE);
 512              	 .loc 2 116 0
 513 013a 0020     	 mov r0,#0
 514 013c 0121     	 mov r1,#1
 515 013e FFF7FEFF 	 bl PDU_Switch_Relay
 117:../operation/operation.c **** 			isPrechargeExecuted					= false;
 516              	 .loc 2 117 0
 517 0142 054B     	 ldr r3,.L19+4
 518 0144 0022     	 mov r2,#0
 519 0146 1A70     	 strb r2,[r3]
 118:../operation/operation.c **** 			ctrlFlag->isPerforming_Precharge	= false;
 520              	 .loc 2 118 0
 521 0148 7B68     	 ldr r3,[r7,#4]
 522 014a 0022     	 mov r2,#0
 523 014c 1A70     	 strb r2,[r3]
 524              	.L12:
 119:../operation/operation.c **** 		}
 120:../operation/operation.c **** 	}
 121:../operation/operation.c **** }
 525              	 .loc 2 121 0
 526 014e BD46     	 mov sp,r7
 527 0150 04B0     	 add sp,sp,#16
 528              	 
 529 0152 80BD     	 pop {r7,pc}
 530              	.L20:
 531              	 .align 2
 532              	.L19:
 533 0154 00020440 	 .word 1074004480
 534 0158 00000000 	 .word isPrechargeExecuted.10968
 535 015c 00000000 	 .word toggle_timer.10967
 536              	 .cfi_endproc
 537              	.LFE381:
 539              	 .section .text.OP_CheckingPCSStatus,"ax",%progbits
 540              	 .align 2
 541              	 .global OP_CheckingPCSStatus
 542              	 .code 16
 543              	 .thumb_func
 545              	OP_CheckingPCSStatus:
 546              	.LFB382:
 122:../operation/operation.c **** 
 123:../operation/operation.c **** void OP_CheckingPCSStatus(OP_STATE_t *state, PCS_STATUS_t *pcsStatus,
 124:../operation/operation.c **** 						  MISC_SYSTICK_PARAM_t *sysTickParam,
 125:../operation/operation.c **** 						  OP_CTRL_FLAG_t *ctrlFlag)
 126:../operation/operation.c **** {
 547              	 .loc 2 126 0
 548              	 .cfi_startproc
 549 0000 80B5     	 push {r7,lr}
 550              	.LCFI9:
 551              	 .cfi_def_cfa_offset 8
 552              	 .cfi_offset 7,-8
 553              	 .cfi_offset 14,-4
 554 0002 84B0     	 sub sp,sp,#16
 555              	.LCFI10:
 556              	 .cfi_def_cfa_offset 24
 557 0004 00AF     	 add r7,sp,#0
 558              	.LCFI11:
 559              	 .cfi_def_cfa_register 7
 560 0006 F860     	 str r0,[r7,#12]
 561 0008 B960     	 str r1,[r7,#8]
 562 000a 7A60     	 str r2,[r7,#4]
 563 000c 3B60     	 str r3,[r7]
 127:../operation/operation.c **** 	static bool toggle_timer = false;
 128:../operation/operation.c **** 	static bool isPutToStandbyExecuted = false;
 129:../operation/operation.c **** 
 130:../operation/operation.c **** 	/* 1. Check PCS Warning Status */
 131:../operation/operation.c **** 	if(pcsStatus->pcs_system_status == PCS_STAT_STANDBY)
 564              	 .loc 2 131 0
 565 000e BB68     	 ldr r3,[r7,#8]
 566 0010 1B78     	 ldrb r3,[r3]
 567 0012 042B     	 cmp r3,#4
 568 0014 02D1     	 bne .L22
 132:../operation/operation.c **** 	{
 133:../operation/operation.c **** 		*state = OP_ERROR;
 569              	 .loc 2 133 0
 570 0016 FB68     	 ldr r3,[r7,#12]
 571 0018 0422     	 mov r2,#4
 572 001a 1A70     	 strb r2,[r3]
 573              	.L22:
 134:../operation/operation.c **** 	}
 135:../operation/operation.c **** 
 136:../operation/operation.c **** 	if(pcsStatus->pcs_system_status == PCS_STAT_INITIAL)
 574              	 .loc 2 136 0
 575 001c BB68     	 ldr r3,[r7,#8]
 576 001e 1B78     	 ldrb r3,[r3]
 577 0020 002B     	 cmp r3,#0
 578 0022 02D1     	 bne .L23
 137:../operation/operation.c **** 	{
 138:../operation/operation.c **** 		*state = OP_SHUTDOWN;
 579              	 .loc 2 138 0
 580 0024 FB68     	 ldr r3,[r7,#12]
 581 0026 0522     	 mov r2,#5
 582 0028 1A70     	 strb r2,[r3]
 583              	.L23:
 139:../operation/operation.c **** 	}
 140:../operation/operation.c **** 
 141:../operation/operation.c **** 	if(!XMC_GPIO_GetInput(P2_2) && !isPutToStandbyExecuted)
 584              	 .loc 2 141 0
 585 002a 3C4B     	 ldr r3,.L29
 586 002c 181C     	 mov r0,r3
 587 002e 0221     	 mov r1,#2
 588 0030 FFF7FEFF 	 bl XMC_GPIO_GetInput
 589 0034 031E     	 sub r3,r0,#0
 590 0036 45D1     	 bne .L24
 591              	 .loc 2 141 0 is_stmt 0 discriminator 1
 592 0038 394B     	 ldr r3,.L29+4
 593 003a 1B78     	 ldrb r3,[r3]
 594 003c 0122     	 mov r2,#1
 595 003e 5340     	 eor r3,r2
 596 0040 DBB2     	 uxtb r3,r3
 597 0042 002B     	 cmp r3,#0
 598 0044 3ED0     	 beq .L24
 142:../operation/operation.c **** 	{
 143:../operation/operation.c **** 		if((!sysTickParam->isTimeOut) && (!sysTickParam->enable) && !toggle_timer)
 599              	 .loc 2 143 0 is_stmt 1
 600 0046 7B68     	 ldr r3,[r7,#4]
 601 0048 1B79     	 ldrb r3,[r3,#4]
 602 004a 0122     	 mov r2,#1
 603 004c 5340     	 eor r3,r2
 604 004e DBB2     	 uxtb r3,r3
 605 0050 002B     	 cmp r3,#0
 606 0052 17D0     	 beq .L25
 607              	 .loc 2 143 0 is_stmt 0 discriminator 1
 608 0054 7B68     	 ldr r3,[r7,#4]
 609 0056 1B78     	 ldrb r3,[r3]
 610 0058 0122     	 mov r2,#1
 611 005a 5340     	 eor r3,r2
 612 005c DBB2     	 uxtb r3,r3
 613 005e 002B     	 cmp r3,#0
 614 0060 10D0     	 beq .L25
 615              	 .loc 2 143 0 discriminator 2
 616 0062 304B     	 ldr r3,.L29+8
 617 0064 1B78     	 ldrb r3,[r3]
 618 0066 0122     	 mov r2,#1
 619 0068 5340     	 eor r3,r2
 620 006a DBB2     	 uxtb r3,r3
 621 006c 002B     	 cmp r3,#0
 622 006e 09D0     	 beq .L25
 144:../operation/operation.c **** 		{
 145:../operation/operation.c **** 			toggle_timer			= true;
 623              	 .loc 2 145 0 is_stmt 1
 624 0070 2C4B     	 ldr r3,.L29+8
 625 0072 0122     	 mov r2,#1
 626 0074 1A70     	 strb r2,[r3]
 146:../operation/operation.c **** 			sysTickParam->enable	= true;
 627              	 .loc 2 146 0
 628 0076 7B68     	 ldr r3,[r7,#4]
 629 0078 0122     	 mov r2,#1
 630 007a 1A70     	 strb r2,[r3]
 147:../operation/operation.c **** 			sysTickParam->count		= 3;
 631              	 .loc 2 147 0
 632 007c 7B68     	 ldr r3,[r7,#4]
 633 007e 0322     	 mov r2,#3
 634 0080 5A80     	 strh r2,[r3,#2]
 635 0082 1EE0     	 b .L26
 636              	.L25:
 148:../operation/operation.c **** 		}
 149:../operation/operation.c **** 		else if ((sysTickParam->isTimeOut) && (!sysTickParam->enable) && !isPutToStandbyExecuted)
 637              	 .loc 2 149 0
 638 0084 7B68     	 ldr r3,[r7,#4]
 639 0086 1B79     	 ldrb r3,[r3,#4]
 640 0088 002B     	 cmp r3,#0
 641 008a 1AD0     	 beq .L26
 642              	 .loc 2 149 0 is_stmt 0 discriminator 1
 643 008c 7B68     	 ldr r3,[r7,#4]
 644 008e 1B78     	 ldrb r3,[r3]
 645 0090 0122     	 mov r2,#1
 646 0092 5340     	 eor r3,r2
 647 0094 DBB2     	 uxtb r3,r3
 648 0096 002B     	 cmp r3,#0
 649 0098 13D0     	 beq .L26
 650              	 .loc 2 149 0 discriminator 2
 651 009a 214B     	 ldr r3,.L29+4
 652 009c 1B78     	 ldrb r3,[r3]
 653 009e 0122     	 mov r2,#1
 654 00a0 5340     	 eor r3,r2
 655 00a2 DBB2     	 uxtb r3,r3
 656 00a4 002B     	 cmp r3,#0
 657 00a6 0CD0     	 beq .L26
 150:../operation/operation.c **** 		{
 151:../operation/operation.c **** 			isPutToStandbyExecuted	= true;
 658              	 .loc 2 151 0 is_stmt 1
 659 00a8 1D4B     	 ldr r3,.L29+4
 660 00aa 0122     	 mov r2,#1
 661 00ac 1A70     	 strb r2,[r3]
 152:../operation/operation.c **** 			toggle_timer			= false;
 662              	 .loc 2 152 0
 663 00ae 1D4B     	 ldr r3,.L29+8
 664 00b0 0022     	 mov r2,#0
 665 00b2 1A70     	 strb r2,[r3]
 153:../operation/operation.c **** 			sysTickParam->isTimeOut = false;
 666              	 .loc 2 153 0
 667 00b4 7B68     	 ldr r3,[r7,#4]
 668 00b6 0022     	 mov r2,#0
 669 00b8 1A71     	 strb r2,[r3,#4]
 154:../operation/operation.c **** 			sysTickParam->count		= 0;
 670              	 .loc 2 154 0
 671 00ba 7B68     	 ldr r3,[r7,#4]
 672 00bc 0022     	 mov r2,#0
 673 00be 5A80     	 strh r2,[r3,#2]
 143:../operation/operation.c **** 		{
 674              	 .loc 2 143 0
 675 00c0 17E0     	 b .L27
 676              	.L26:
 677 00c2 16E0     	 b .L27
 678              	.L24:
 155:../operation/operation.c **** 		}
 156:../operation/operation.c **** 	}
 157:../operation/operation.c **** 	else if(XMC_GPIO_GetInput(P2_2) && !isPutToStandbyExecuted)
 679              	 .loc 2 157 0
 680 00c4 154B     	 ldr r3,.L29
 681 00c6 181C     	 mov r0,r3
 682 00c8 0221     	 mov r1,#2
 683 00ca FFF7FEFF 	 bl XMC_GPIO_GetInput
 684 00ce 031E     	 sub r3,r0,#0
 685 00d0 0FD0     	 beq .L27
 686              	 .loc 2 157 0 is_stmt 0 discriminator 1
 687 00d2 134B     	 ldr r3,.L29+4
 688 00d4 1B78     	 ldrb r3,[r3]
 689 00d6 0122     	 mov r2,#1
 690 00d8 5340     	 eor r3,r2
 691 00da DBB2     	 uxtb r3,r3
 692 00dc 002B     	 cmp r3,#0
 693 00de 08D0     	 beq .L27
 158:../operation/operation.c **** 	{
 159:../operation/operation.c **** 		toggle_timer			= false;
 694              	 .loc 2 159 0 is_stmt 1
 695 00e0 104B     	 ldr r3,.L29+8
 696 00e2 0022     	 mov r2,#0
 697 00e4 1A70     	 strb r2,[r3]
 160:../operation/operation.c **** 		sysTickParam->enable 	= false;
 698              	 .loc 2 160 0
 699 00e6 7B68     	 ldr r3,[r7,#4]
 700 00e8 0022     	 mov r2,#0
 701 00ea 1A70     	 strb r2,[r3]
 161:../operation/operation.c **** 		sysTickParam->count 	= 0;
 702              	 .loc 2 161 0
 703 00ec 7B68     	 ldr r3,[r7,#4]
 704 00ee 0022     	 mov r2,#0
 705 00f0 5A80     	 strh r2,[r3,#2]
 706              	.L27:
 162:../operation/operation.c **** 	}
 163:../operation/operation.c **** 
 164:../operation/operation.c **** 	/* Change to STANDBY upon the timer's time-out and button is released */
 165:../operation/operation.c **** 	if(isPutToStandbyExecuted)
 707              	 .loc 2 165 0
 708 00f2 0B4B     	 ldr r3,.L29+4
 709 00f4 1B78     	 ldrb r3,[r3]
 710 00f6 002B     	 cmp r3,#0
 711 00f8 0CD0     	 beq .L21
 166:../operation/operation.c **** 	{
 167:../operation/operation.c **** 		if(XMC_GPIO_GetInput(P2_2))
 712              	 .loc 2 167 0
 713 00fa 084B     	 ldr r3,.L29
 714 00fc 181C     	 mov r0,r3
 715 00fe 0221     	 mov r1,#2
 716 0100 FFF7FEFF 	 bl XMC_GPIO_GetInput
 717 0104 031E     	 sub r3,r0,#0
 718 0106 05D0     	 beq .L21
 168:../operation/operation.c **** 		{
 169:../operation/operation.c **** 			isPutToStandbyExecuted	= false;
 719              	 .loc 2 169 0
 720 0108 054B     	 ldr r3,.L29+4
 721 010a 0022     	 mov r2,#0
 722 010c 1A70     	 strb r2,[r3]
 170:../operation/operation.c **** 			*state					= OP_STANDBY;
 723              	 .loc 2 170 0
 724 010e FB68     	 ldr r3,[r7,#12]
 725 0110 0322     	 mov r2,#3
 726 0112 1A70     	 strb r2,[r3]
 727              	.L21:
 171:../operation/operation.c **** 		}
 172:../operation/operation.c **** 	}
 173:../operation/operation.c **** }
 728              	 .loc 2 173 0
 729 0114 BD46     	 mov sp,r7
 730 0116 04B0     	 add sp,sp,#16
 731              	 
 732 0118 80BD     	 pop {r7,pc}
 733              	.L30:
 734 011a C046     	 .align 2
 735              	.L29:
 736 011c 00020440 	 .word 1074004480
 737 0120 00000000 	 .word isPutToStandbyExecuted.10976
 738 0124 00000000 	 .word toggle_timer.10975
 739              	 .cfi_endproc
 740              	.LFE382:
 742              	 .section .text.OP_PutSystemStandby,"ax",%progbits
 743              	 .align 2
 744              	 .global OP_PutSystemStandby
 745              	 .code 16
 746              	 .thumb_func
 748              	OP_PutSystemStandby:
 749              	.LFB383:
 174:../operation/operation.c **** 
 175:../operation/operation.c **** void OP_PutSystemStandby(OP_STATE_t *state, PCS_STATUS_t *pcsStatus,
 176:../operation/operation.c **** 						 OP_CTRL_FLAG_t *ctrlFlag,
 177:../operation/operation.c **** 						 PCS_BMC_STATUS_t *pcsBmsStatus)
 178:../operation/operation.c **** {
 750              	 .loc 2 178 0
 751              	 .cfi_startproc
 752 0000 80B5     	 push {r7,lr}
 753              	.LCFI12:
 754              	 .cfi_def_cfa_offset 8
 755              	 .cfi_offset 7,-8
 756              	 .cfi_offset 14,-4
 757 0002 84B0     	 sub sp,sp,#16
 758              	.LCFI13:
 759              	 .cfi_def_cfa_offset 24
 760 0004 00AF     	 add r7,sp,#0
 761              	.LCFI14:
 762              	 .cfi_def_cfa_register 7
 763 0006 F860     	 str r0,[r7,#12]
 764 0008 B960     	 str r1,[r7,#8]
 765 000a 7A60     	 str r2,[r7,#4]
 766 000c 3B60     	 str r3,[r7]
 179:../operation/operation.c **** 	static bool isStandbyExecuted = false;
 180:../operation/operation.c **** 
 181:../operation/operation.c **** 	if(pcsStatus->pcs_system_status == PCS_STAT_RUNNING)
 767              	 .loc 2 181 0
 768 000e BB68     	 ldr r3,[r7,#8]
 769 0010 1B78     	 ldrb r3,[r3]
 770 0012 062B     	 cmp r3,#6
 771 0014 0CD1     	 bne .L32
 182:../operation/operation.c **** 	{
 183:../operation/operation.c **** 		if(!isStandbyExecuted)
 772              	 .loc 2 183 0
 773 0016 154B     	 ldr r3,.L34
 774 0018 1B78     	 ldrb r3,[r3]
 775 001a 0122     	 mov r2,#1
 776 001c 5340     	 eor r3,r2
 777 001e DBB2     	 uxtb r3,r3
 778 0020 002B     	 cmp r3,#0
 779 0022 05D0     	 beq .L32
 184:../operation/operation.c **** 		{
 185:../operation/operation.c **** 			pcsBmsStatus->bmc_pcs_command = BMU_PCS_STOP;
 780              	 .loc 2 185 0
 781 0024 3B68     	 ldr r3,[r7]
 782 0026 0022     	 mov r2,#0
 783 0028 5A70     	 strb r2,[r3,#1]
 186:../operation/operation.c **** 			isStandbyExecuted = true;
 784              	 .loc 2 186 0
 785 002a 104B     	 ldr r3,.L34
 786 002c 0122     	 mov r2,#1
 787 002e 1A70     	 strb r2,[r3]
 788              	.L32:
 187:../operation/operation.c **** 		}
 188:../operation/operation.c **** 	}
 189:../operation/operation.c **** 
 190:../operation/operation.c **** 	if(pcsStatus->pcs_system_status == PCS_STAT_STANDBY)
 789              	 .loc 2 190 0
 790 0030 BB68     	 ldr r3,[r7,#8]
 791 0032 1B78     	 ldrb r3,[r3]
 792 0034 042B     	 cmp r3,#4
 793 0036 16D1     	 bne .L31
 191:../operation/operation.c **** 	{
 192:../operation/operation.c **** 		/* Close Pre Discharge Relay */
 193:../operation/operation.c **** 		PDU_Switch_Relay(PDU_RELAY_KDSG, PDU_RELAY_CLOSE);
 794              	 .loc 2 193 0
 795 0038 0320     	 mov r0,#3
 796 003a 0121     	 mov r1,#1
 797 003c FFF7FEFF 	 bl PDU_Switch_Relay
 194:../operation/operation.c **** 
 195:../operation/operation.c **** 		/* Open Main Relay */
 196:../operation/operation.c **** 		PDU_Switch_Relay(PDU_RELAY_KMP, PDU_RELAY_OPEN);
 798              	 .loc 2 196 0
 799 0040 0120     	 mov r0,#1
 800 0042 0021     	 mov r1,#0
 801 0044 FFF7FEFF 	 bl PDU_Switch_Relay
 197:../operation/operation.c **** 
 198:../operation/operation.c **** 		pcsBmsStatus->bmc_main_relay		= RELAY_OPEN;
 802              	 .loc 2 198 0
 803 0048 3B68     	 ldr r3,[r7]
 804 004a 0022     	 mov r2,#0
 805 004c 9A70     	 strb r2,[r3,#2]
 199:../operation/operation.c **** 		pcsBmsStatus->bmc_precharge_relay	= RELAY_CLOSE;
 806              	 .loc 2 199 0
 807 004e 3B68     	 ldr r3,[r7]
 808 0050 0122     	 mov r2,#1
 809 0052 DA70     	 strb r2,[r3,#3]
 200:../operation/operation.c **** 		pcsBmsStatus->bmc_status			= BMU_PRECHARGE;
 810              	 .loc 2 200 0
 811 0054 3B68     	 ldr r3,[r7]
 812 0056 0122     	 mov r2,#1
 813 0058 1A70     	 strb r2,[r3]
 201:../operation/operation.c **** 
 202:../operation/operation.c **** 		*state = OP_TURN_ON;
 814              	 .loc 2 202 0
 815 005a FB68     	 ldr r3,[r7,#12]
 816 005c 0122     	 mov r2,#1
 817 005e 1A70     	 strb r2,[r3]
 203:../operation/operation.c **** 		isStandbyExecuted = false;
 818              	 .loc 2 203 0
 819 0060 024B     	 ldr r3,.L34
 820 0062 0022     	 mov r2,#0
 821 0064 1A70     	 strb r2,[r3]
 822              	.L31:
 204:../operation/operation.c **** 	}
 205:../operation/operation.c **** }
 823              	 .loc 2 205 0
 824 0066 BD46     	 mov sp,r7
 825 0068 04B0     	 add sp,sp,#16
 826              	 
 827 006a 80BD     	 pop {r7,pc}
 828              	.L35:
 829              	 .align 2
 830              	.L34:
 831 006c 00000000 	 .word isStandbyExecuted.10983
 832              	 .cfi_endproc
 833              	.LFE383:
 835              	 .section .text.OP_HandlingPCSWarning,"ax",%progbits
 836              	 .align 2
 837              	 .global OP_HandlingPCSWarning
 838              	 .code 16
 839              	 .thumb_func
 841              	OP_HandlingPCSWarning:
 842              	.LFB384:
 206:../operation/operation.c **** 
 207:../operation/operation.c **** void OP_HandlingPCSWarning(OP_STATE_t *state, PCS_STATUS_t *pcsStatus,
 208:../operation/operation.c **** 						   MISC_SYSTICK_PARAM_t *sysTickParam,
 209:../operation/operation.c **** 						   OP_CTRL_FLAG_t *ctrlFlag, BMC_PARAMETER_t *bmsParam,
 210:../operation/operation.c **** 						   PCS_BMC_STATUS_t *pcsBmsStatus)
 211:../operation/operation.c **** {
 843              	 .loc 2 211 0
 844              	 .cfi_startproc
 845 0000 80B5     	 push {r7,lr}
 846              	.LCFI15:
 847              	 .cfi_def_cfa_offset 8
 848              	 .cfi_offset 7,-8
 849              	 .cfi_offset 14,-4
 850 0002 84B0     	 sub sp,sp,#16
 851              	.LCFI16:
 852              	 .cfi_def_cfa_offset 24
 853 0004 00AF     	 add r7,sp,#0
 854              	.LCFI17:
 855              	 .cfi_def_cfa_register 7
 856 0006 F860     	 str r0,[r7,#12]
 857 0008 B960     	 str r1,[r7,#8]
 858 000a 7A60     	 str r2,[r7,#4]
 859 000c 3B60     	 str r3,[r7]
 212:../operation/operation.c **** 
 213:../operation/operation.c **** 	/* 1. if error elapsed, attempt for change PCS to RUN state */
 214:../operation/operation.c **** 	if(!ctrlFlag->isStandby)
 860              	 .loc 2 214 0
 861 000e 3B68     	 ldr r3,[r7]
 862 0010 5B78     	 ldrb r3,[r3,#1]
 863 0012 0122     	 mov r2,#1
 864 0014 5340     	 eor r3,r2
 865 0016 DBB2     	 uxtb r3,r3
 866 0018 002B     	 cmp r3,#0
 867 001a 02D0     	 beq .L37
 215:../operation/operation.c **** 	{
 216:../operation/operation.c **** 		pcsBmsStatus->bmc_pcs_command = BMU_PCS_START;
 868              	 .loc 2 216 0
 869 001c FB69     	 ldr r3,[r7,#28]
 870 001e 0122     	 mov r2,#1
 871 0020 5A70     	 strb r2,[r3,#1]
 872              	.L37:
 217:../operation/operation.c **** 	}
 218:../operation/operation.c **** 
 219:../operation/operation.c **** 	/* 1. if PCS acknowledged that already change to RUN, return the state to RUNNING */
 220:../operation/operation.c **** 	if(pcsStatus->pcs_system_status == PCS_STAT_RUNNING)
 873              	 .loc 2 220 0
 874 0022 BB68     	 ldr r3,[r7,#8]
 875 0024 1B78     	 ldrb r3,[r3]
 876 0026 062B     	 cmp r3,#6
 877 0028 02D1     	 bne .L38
 221:../operation/operation.c **** 	{
 222:../operation/operation.c **** 		*state = OP_RUNNING;
 878              	 .loc 2 222 0
 879 002a FB68     	 ldr r3,[r7,#12]
 880 002c 0222     	 mov r2,#2
 881 002e 1A70     	 strb r2,[r3]
 882              	.L38:
 223:../operation/operation.c **** 	}
 224:../operation/operation.c **** 	/* 2. Check SoC Level and BMC Dip Switch Mode*/
 225:../operation/operation.c **** 	if((pcsStatus->pcs_system_status == PCS_STAT_INITIAL) || (!ctrlFlag->isBypass_power_mode && bmsPar
 883              	 .loc 2 225 0
 884 0030 BB68     	 ldr r3,[r7,#8]
 885 0032 1B78     	 ldrb r3,[r3]
 886 0034 002B     	 cmp r3,#0
 887 0036 0AD0     	 beq .L39
 888              	 .loc 2 225 0 is_stmt 0 discriminator 1
 889 0038 3B68     	 ldr r3,[r7]
 890 003a DB78     	 ldrb r3,[r3,#3]
 891 003c 0122     	 mov r2,#1
 892 003e 5340     	 eor r3,r2
 893 0040 DBB2     	 uxtb r3,r3
 894 0042 002B     	 cmp r3,#0
 895 0044 06D0     	 beq .L36
 896              	 .loc 2 225 0 discriminator 2
 897 0046 BB69     	 ldr r3,[r7,#24]
 898 0048 1B88     	 ldrh r3,[r3]
 899 004a 312B     	 cmp r3,#49
 900 004c 02D8     	 bhi .L36
 901              	.L39:
 226:../operation/operation.c **** 	{
 227:../operation/operation.c **** 		*state = OP_SHUTDOWN;
 902              	 .loc 2 227 0 is_stmt 1
 903 004e FB68     	 ldr r3,[r7,#12]
 904 0050 0522     	 mov r2,#5
 905 0052 1A70     	 strb r2,[r3]
 906              	.L36:
 228:../operation/operation.c **** 	}
 229:../operation/operation.c **** }
 907              	 .loc 2 229 0
 908 0054 BD46     	 mov sp,r7
 909 0056 04B0     	 add sp,sp,#16
 910              	 
 911 0058 80BD     	 pop {r7,pc}
 912              	 .cfi_endproc
 913              	.LFE384:
 915 005a C046     	 .section .text.OP_PutSystemShutDown,"ax",%progbits
 916              	 .align 2
 917              	 .global OP_PutSystemShutDown
 918              	 .code 16
 919              	 .thumb_func
 921              	OP_PutSystemShutDown:
 922              	.LFB385:
 230:../operation/operation.c **** 
 231:../operation/operation.c **** void OP_PutSystemShutDown(OP_STATE_t *state, MISC_SYSTICK_PARAM_t *sysTickParam, OP_CTRL_FLAG_t *ct
 232:../operation/operation.c **** 						  PCS_BMC_STATUS_t *pcsBmsStatus)
 233:../operation/operation.c **** {
 923              	 .loc 2 233 0
 924              	 .cfi_startproc
 925 0000 80B5     	 push {r7,lr}
 926              	.LCFI18:
 927              	 .cfi_def_cfa_offset 8
 928              	 .cfi_offset 7,-8
 929              	 .cfi_offset 14,-4
 930 0002 84B0     	 sub sp,sp,#16
 931              	.LCFI19:
 932              	 .cfi_def_cfa_offset 24
 933 0004 00AF     	 add r7,sp,#0
 934              	.LCFI20:
 935              	 .cfi_def_cfa_register 7
 936 0006 F860     	 str r0,[r7,#12]
 937 0008 B960     	 str r1,[r7,#8]
 938 000a 7A60     	 str r2,[r7,#4]
 939 000c 3B60     	 str r3,[r7]
 234:../operation/operation.c **** 	if(!sysTickParam->isTimeOut)
 940              	 .loc 2 234 0
 941 000e BB68     	 ldr r3,[r7,#8]
 942 0010 1B79     	 ldrb r3,[r3,#4]
 943 0012 0122     	 mov r2,#1
 944 0014 5340     	 eor r3,r2
 945 0016 DBB2     	 uxtb r3,r3
 946 0018 002B     	 cmp r3,#0
 947 001a 06D0     	 beq .L42
 235:../operation/operation.c **** 	{
 236:../operation/operation.c **** 		sysTickParam->enable	= true;
 948              	 .loc 2 236 0
 949 001c BB68     	 ldr r3,[r7,#8]
 950 001e 0122     	 mov r2,#1
 951 0020 1A70     	 strb r2,[r3]
 237:../operation/operation.c **** 		sysTickParam->count		= 10;
 952              	 .loc 2 237 0
 953 0022 BB68     	 ldr r3,[r7,#8]
 954 0024 0A22     	 mov r2,#10
 955 0026 5A80     	 strh r2,[r3,#2]
 956 0028 28E0     	 b .L41
 957              	.L42:
 238:../operation/operation.c **** 	}
 239:../operation/operation.c **** 	else
 240:../operation/operation.c **** 	{
 241:../operation/operation.c **** 		sysTickParam->isTimeOut = false;
 958              	 .loc 2 241 0
 959 002a BB68     	 ldr r3,[r7,#8]
 960 002c 0022     	 mov r2,#0
 961 002e 1A71     	 strb r2,[r3,#4]
 242:../operation/operation.c **** 		sysTickParam->count = 0;
 962              	 .loc 2 242 0
 963 0030 BB68     	 ldr r3,[r7,#8]
 964 0032 0022     	 mov r2,#0
 965 0034 5A80     	 strh r2,[r3,#2]
 243:../operation/operation.c **** 
 244:../operation/operation.c **** 		/* Close Pre Discharge Relay */
 245:../operation/operation.c **** 		PDU_Switch_Relay(PDU_RELAY_KDSG, PDU_RELAY_CLOSE);
 966              	 .loc 2 245 0
 967 0036 0320     	 mov r0,#3
 968 0038 0121     	 mov r1,#1
 969 003a FFF7FEFF 	 bl PDU_Switch_Relay
 246:../operation/operation.c **** 
 247:../operation/operation.c **** 		/* Open Main Relay */
 248:../operation/operation.c **** 		PDU_Switch_Relay(PDU_RELAY_KMP, PDU_RELAY_OPEN);
 970              	 .loc 2 248 0
 971 003e 0120     	 mov r0,#1
 972 0040 0021     	 mov r1,#0
 973 0042 FFF7FEFF 	 bl PDU_Switch_Relay
 249:../operation/operation.c **** 		pcsBmsStatus->bmc_main_relay		= RELAY_OPEN;
 974              	 .loc 2 249 0
 975 0046 3B68     	 ldr r3,[r7]
 976 0048 0022     	 mov r2,#0
 977 004a 9A70     	 strb r2,[r3,#2]
 250:../operation/operation.c **** 		pcsBmsStatus->bmc_precharge_relay	= RELAY_CLOSE;
 978              	 .loc 2 250 0
 979 004c 3B68     	 ldr r3,[r7]
 980 004e 0122     	 mov r2,#1
 981 0050 DA70     	 strb r2,[r3,#3]
 251:../operation/operation.c **** 		pcsBmsStatus->bmc_status			= BMU_PRECHARGE;
 982              	 .loc 2 251 0
 983 0052 3B68     	 ldr r3,[r7]
 984 0054 0122     	 mov r2,#1
 985 0056 1A70     	 strb r2,[r3]
 252:../operation/operation.c **** 		if(!ctrlFlag->isBypass_power_mode)
 986              	 .loc 2 252 0
 987 0058 7B68     	 ldr r3,[r7,#4]
 988 005a DB78     	 ldrb r3,[r3,#3]
 989 005c 0122     	 mov r2,#1
 990 005e 5340     	 eor r3,r2
 991 0060 DBB2     	 uxtb r3,r3
 992 0062 002B     	 cmp r3,#0
 993 0064 07D0     	 beq .L44
 253:../operation/operation.c **** 		{
 254:../operation/operation.c **** 			PDU_Switch_Relay(PDU_RELAY_KBAT, PDU_RELAY_OPEN);
 994              	 .loc 2 254 0
 995 0066 0020     	 mov r0,#0
 996 0068 0021     	 mov r1,#0
 997 006a FFF7FEFF 	 bl PDU_Switch_Relay
 255:../operation/operation.c **** 			*state = OP_POWERUP;
 998              	 .loc 2 255 0
 999 006e FB68     	 ldr r3,[r7,#12]
 1000 0070 0022     	 mov r2,#0
 1001 0072 1A70     	 strb r2,[r3]
 1002 0074 02E0     	 b .L41
 1003              	.L44:
 256:../operation/operation.c **** 		}
 257:../operation/operation.c **** 		else
 258:../operation/operation.c **** 		{
 259:../operation/operation.c **** 			*state = OP_TURN_ON;
 1004              	 .loc 2 259 0
 1005 0076 FB68     	 ldr r3,[r7,#12]
 1006 0078 0122     	 mov r2,#1
 1007 007a 1A70     	 strb r2,[r3]
 1008              	.L41:
 260:../operation/operation.c **** 		}
 261:../operation/operation.c **** 	}
 262:../operation/operation.c **** }
 1009              	 .loc 2 262 0
 1010 007c BD46     	 mov sp,r7
 1011 007e 04B0     	 add sp,sp,#16
 1012              	 
 1013 0080 80BD     	 pop {r7,pc}
 1014              	 .cfi_endproc
 1015              	.LFE385:
 1017 0082 C046     	 .section .text.OP_CheckingMode,"ax",%progbits
 1018              	 .align 2
 1019              	 .global OP_CheckingMode
 1020              	 .code 16
 1021              	 .thumb_func
 1023              	OP_CheckingMode:
 1024              	.LFB386:
 263:../operation/operation.c **** 
 264:../operation/operation.c **** void OP_CheckingMode(OP_CTRL_FLAG_t *ctrlFlag)
 265:../operation/operation.c **** {
 1025              	 .loc 2 265 0
 1026              	 .cfi_startproc
 1027 0000 80B5     	 push {r7,lr}
 1028              	.LCFI21:
 1029              	 .cfi_def_cfa_offset 8
 1030              	 .cfi_offset 7,-8
 1031              	 .cfi_offset 14,-4
 1032 0002 82B0     	 sub sp,sp,#8
 1033              	.LCFI22:
 1034              	 .cfi_def_cfa_offset 16
 1035 0004 00AF     	 add r7,sp,#0
 1036              	.LCFI23:
 1037              	 .cfi_def_cfa_register 7
 1038 0006 7860     	 str r0,[r7,#4]
 266:../operation/operation.c **** 	/* Read Dip Switch */
 267:../operation/operation.c **** 	(XMC_GPIO_GetInput(P4_2) == 1)?(ctrlFlag->isBypass_power_mode = true):
 1039              	 .loc 2 267 0
 1040 0008 1F4B     	 ldr r3,.L54
 1041 000a 181C     	 mov r0,r3
 1042 000c 0221     	 mov r1,#2
 1043 000e FFF7FEFF 	 bl XMC_GPIO_GetInput
 1044 0012 031E     	 sub r3,r0,#0
 1045 0014 012B     	 cmp r3,#1
 1046 0016 03D1     	 bne .L46
 1047              	 .loc 2 267 0 is_stmt 0 discriminator 1
 1048 0018 7B68     	 ldr r3,[r7,#4]
 1049 001a 0122     	 mov r2,#1
 1050 001c DA70     	 strb r2,[r3,#3]
 1051 001e 02E0     	 b .L47
 1052              	.L46:
 268:../operation/operation.c **** 								   (ctrlFlag->isBypass_power_mode = false);
 1053              	 .loc 2 268 0 is_stmt 1 discriminator 2
 1054 0020 7B68     	 ldr r3,[r7,#4]
 1055 0022 0022     	 mov r2,#0
 1056 0024 DA70     	 strb r2,[r3,#3]
 1057              	.L47:
 269:../operation/operation.c **** 	(XMC_GPIO_GetInput(P4_3) == 1)?(ctrlFlag->isAuto_mode = true):
 1058              	 .loc 2 269 0
 1059 0026 184B     	 ldr r3,.L54
 1060 0028 181C     	 mov r0,r3
 1061 002a 0321     	 mov r1,#3
 1062 002c FFF7FEFF 	 bl XMC_GPIO_GetInput
 1063 0030 031E     	 sub r3,r0,#0
 1064 0032 012B     	 cmp r3,#1
 1065 0034 03D1     	 bne .L48
 1066              	 .loc 2 269 0 is_stmt 0 discriminator 1
 1067 0036 7B68     	 ldr r3,[r7,#4]
 1068 0038 0122     	 mov r2,#1
 1069 003a 9A70     	 strb r2,[r3,#2]
 1070 003c 02E0     	 b .L49
 1071              	.L48:
 270:../operation/operation.c **** 								   (ctrlFlag->isAuto_mode = false);
 1072              	 .loc 2 270 0 is_stmt 1 discriminator 2
 1073 003e 7B68     	 ldr r3,[r7,#4]
 1074 0040 0022     	 mov r2,#0
 1075 0042 9A70     	 strb r2,[r3,#2]
 1076              	.L49:
 271:../operation/operation.c **** 	(XMC_GPIO_GetInput(P4_4) == 1)?(ctrlFlag->isChecking_peripheral = true):
 1077              	 .loc 2 271 0
 1078 0044 104B     	 ldr r3,.L54
 1079 0046 181C     	 mov r0,r3
 1080 0048 0421     	 mov r1,#4
 1081 004a FFF7FEFF 	 bl XMC_GPIO_GetInput
 1082 004e 031E     	 sub r3,r0,#0
 1083 0050 012B     	 cmp r3,#1
 1084 0052 03D1     	 bne .L50
 1085              	 .loc 2 271 0 is_stmt 0 discriminator 1
 1086 0054 7B68     	 ldr r3,[r7,#4]
 1087 0056 0122     	 mov r2,#1
 1088 0058 5A71     	 strb r2,[r3,#5]
 1089 005a 02E0     	 b .L51
 1090              	.L50:
 272:../operation/operation.c **** 								   (ctrlFlag->isChecking_peripheral = false);
 1091              	 .loc 2 272 0 is_stmt 1 discriminator 2
 1092 005c 7B68     	 ldr r3,[r7,#4]
 1093 005e 0022     	 mov r2,#0
 1094 0060 5A71     	 strb r2,[r3,#5]
 1095              	.L51:
 273:../operation/operation.c **** 	(XMC_GPIO_GetInput(P4_5) == 1)?(ctrlFlag->isForced_shutting_down = true):
 1096              	 .loc 2 273 0
 1097 0062 094B     	 ldr r3,.L54
 1098 0064 181C     	 mov r0,r3
 1099 0066 0521     	 mov r1,#5
 1100 0068 FFF7FEFF 	 bl XMC_GPIO_GetInput
 1101 006c 031E     	 sub r3,r0,#0
 1102 006e 012B     	 cmp r3,#1
 1103 0070 03D1     	 bne .L52
 1104              	 .loc 2 273 0 is_stmt 0 discriminator 1
 1105 0072 7B68     	 ldr r3,[r7,#4]
 1106 0074 0122     	 mov r2,#1
 1107 0076 1A71     	 strb r2,[r3,#4]
 1108 0078 02E0     	 b .L45
 1109              	.L52:
 274:../operation/operation.c **** 								   (ctrlFlag->isForced_shutting_down = false);
 1110              	 .loc 2 274 0 is_stmt 1 discriminator 2
 1111 007a 7B68     	 ldr r3,[r7,#4]
 1112 007c 0022     	 mov r2,#0
 1113 007e 1A71     	 strb r2,[r3,#4]
 1114              	.L45:
 275:../operation/operation.c **** }
 1115              	 .loc 2 275 0
 1116 0080 BD46     	 mov sp,r7
 1117 0082 02B0     	 add sp,sp,#8
 1118              	 
 1119 0084 80BD     	 pop {r7,pc}
 1120              	.L55:
 1121 0086 C046     	 .align 2
 1122              	.L54:
 1123 0088 00040440 	 .word 1074004992
 1124              	 .cfi_endproc
 1125              	.LFE386:
 1127              	 .section .text.OP_CheckingError,"ax",%progbits
 1128              	 .align 2
 1129              	 .global OP_CheckingError
 1130              	 .code 16
 1131              	 .thumb_func
 1133              	OP_CheckingError:
 1134              	.LFB387:
 276:../operation/operation.c **** 
 277:../operation/operation.c **** void OP_CheckingError(OP_CTRL_FLAG_t *ctrlFlag, PCS_STATUS_t *pcsStatus,
 278:../operation/operation.c **** 					  DCGRID_STATUS_t *gridStatus, ACINV_STATUS_t *invStatus,
 279:../operation/operation.c **** 					  PVCONV_STATUS_t *pvStatus, BATCONV_STATUS_t *BatStatus)
 280:../operation/operation.c **** {
 1135              	 .loc 2 280 0
 1136              	 .cfi_startproc
 1137 0000 80B5     	 push {r7,lr}
 1138              	.LCFI24:
 1139              	 .cfi_def_cfa_offset 8
 1140              	 .cfi_offset 7,-8
 1141              	 .cfi_offset 14,-4
 1142 0002 84B0     	 sub sp,sp,#16
 1143              	.LCFI25:
 1144              	 .cfi_def_cfa_offset 24
 1145 0004 00AF     	 add r7,sp,#0
 1146              	.LCFI26:
 1147              	 .cfi_def_cfa_register 7
 1148 0006 F860     	 str r0,[r7,#12]
 1149 0008 B960     	 str r1,[r7,#8]
 1150 000a 7A60     	 str r2,[r7,#4]
 1151 000c 3B60     	 str r3,[r7]
 281:../operation/operation.c **** 	  /* Check if any system in Standby mode */
 282:../operation/operation.c **** 	ctrlFlag->isStandby = pcsStatus->pcs_system_pcsIsStandBy 	 |\
 1152              	 .loc 2 282 0
 1153 000e BB68     	 ldr r3,[r7,#8]
 1154 0010 1B79     	 ldrb r3,[r3,#4]
 1155 0012 1A1C     	 mov r2,r3
 283:../operation/operation.c **** 						  gridStatus->dcgrid_system_pcsIsStandBy |\
 1156              	 .loc 2 283 0
 1157 0014 7B68     	 ldr r3,[r7,#4]
 1158 0016 DB78     	 ldrb r3,[r3,#3]
 282:../operation/operation.c **** 						  gridStatus->dcgrid_system_pcsIsStandBy |\
 1159              	 .loc 2 282 0
 1160 0018 1343     	 orr r3,r2
 284:../operation/operation.c **** 						  invStatus->acinv_system_pcsIsStandBy	 |\
 1161              	 .loc 2 284 0
 1162 001a 3A68     	 ldr r2,[r7]
 1163 001c D278     	 ldrb r2,[r2,#3]
 283:../operation/operation.c **** 						  gridStatus->dcgrid_system_pcsIsStandBy |\
 1164              	 .loc 2 283 0
 1165 001e 1343     	 orr r3,r2
 285:../operation/operation.c **** 						  pvStatus->pvconv_system_pcsIsStandBy   |\
 1166              	 .loc 2 285 0
 1167 0020 BA69     	 ldr r2,[r7,#24]
 1168 0022 D278     	 ldrb r2,[r2,#3]
 284:../operation/operation.c **** 						  invStatus->acinv_system_pcsIsStandBy	 |\
 1169              	 .loc 2 284 0
 1170 0024 1343     	 orr r3,r2
 286:../operation/operation.c **** 						  BatStatus->batconv_system_pcsIsStandBy;
 1171              	 .loc 2 286 0
 1172 0026 FA69     	 ldr r2,[r7,#28]
 1173 0028 D278     	 ldrb r2,[r2,#3]
 285:../operation/operation.c **** 						  pvStatus->pvconv_system_pcsIsStandBy   |\
 1174              	 .loc 2 285 0
 1175 002a 1343     	 orr r3,r2
 1176 002c 5A1E     	 sub r2,r3,#1
 1177 002e 9341     	 sbc r3,r3,r2
 1178 0030 DAB2     	 uxtb r2,r3
 282:../operation/operation.c **** 						  gridStatus->dcgrid_system_pcsIsStandBy |\
 1179              	 .loc 2 282 0
 1180 0032 FB68     	 ldr r3,[r7,#12]
 1181 0034 5A70     	 strb r2,[r3,#1]
 287:../operation/operation.c **** }
 1182              	 .loc 2 287 0
 1183 0036 BD46     	 mov sp,r7
 1184 0038 04B0     	 add sp,sp,#16
 1185              	 
 1186 003a 80BD     	 pop {r7,pc}
 1187              	 .cfi_endproc
 1188              	.LFE387:
 1190              	 .section .bss.toggle_timer.10959,"aw",%nobits
 1193              	toggle_timer.10959:
 1194 0000 00       	 .space 1
 1195              	 .section .bss.isPrechargeExecuted.10968,"aw",%nobits
 1198              	isPrechargeExecuted.10968:
 1199 0000 00       	 .space 1
 1200              	 .section .bss.toggle_timer.10967,"aw",%nobits
 1203              	toggle_timer.10967:
 1204 0000 00       	 .space 1
 1205              	 .section .bss.isPutToStandbyExecuted.10976,"aw",%nobits
 1208              	isPutToStandbyExecuted.10976:
 1209 0000 00       	 .space 1
 1210              	 .section .bss.toggle_timer.10975,"aw",%nobits
 1213              	toggle_timer.10975:
 1214 0000 00       	 .space 1
 1215              	 .section .bss.isStandbyExecuted.10983,"aw",%nobits
 1218              	isStandbyExecuted.10983:
 1219 0000 00       	 .space 1
 1220              	 .text
 1221              	.Letext0:
 1222              	 .file 3 "d:\\software\\dave_4-4-2_64bit_2018-02-23\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1223              	 .file 4 "d:\\software\\dave_4-4-2_64bit_2018-02-23\\dave_4-4-2_64bit_2018-02-23\\dave-ide-4.4.2-64bit\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1224              	 .file 5 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/CMSIS/Infineon/XMC1400_series/Include/XMC1400.h"
 1225              	 .file 6 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc1_gpio.h"
 1226              	 .file 7 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_usic.h"
 1227              	 .file 8 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_uart.h"
 1228              	 .file 9 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/esp32/esp32_op.h"
 1229              	 .file 10 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_ccu4.h"
 1230              	 .file 11 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_can.h"
 1231              	 .file 12 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/pcs/pcs_op.h"
 1232              	 .file 13 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/genix/genix_op.h"
 1233              	 .file 14 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/XMCLib/inc/xmc_vadc.h"
 1234              	 .file 15 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/pdu/pdu_op.h"
 1235              	 .file 16 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/variables/variables.h"
 1236              	 .file 17 "../operation/operation.h"
 1237              	 .file 18 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/CMSIS/Include/cmsis_gcc.h"
 1238              	 .file 19 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/Libraries/CMSIS/Infineon/XMC1400_series/Include/system_XMC1400.h"
 1239              	 .file 20 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/esp32/esp32_op_conf.h"
 1240              	 .file 21 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/pcs/pcs_op_conf.h"
 1241              	 .file 22 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/genix/genix_op_conf.h"
 1242              	 .file 23 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/gpios/gpio_op_conf.h"
 1243              	 .file 24 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/pdu/pdu_op_conf.h"
 1244              	 .file 25 "C:/Users/Lenovo/workspace/dave_workspace/SOLAR_TOWER_XMC/interconnect/timing/timing_op_conf.h"
DEFINED SYMBOLS
                            *ABS*:00000000 operation.c
    {standard input}:18     .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:22     .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
                            *COM*:00000008 tx_config
                            *COM*:00000008 rx_config
                            *COM*:0000000c uart_config
                            *COM*:00000008 pcs_button_config
                            *COM*:00000008 CAN0_txd_config
                            *COM*:00000008 CAN0_rxd_config
                            *COM*:0000000c can_baud
                            *COM*:00000020 msgObjToPCS
                            *COM*:00000020 msgObjFromPCS
                            *COM*:00000008 tx_genix_config
                            *COM*:00000008 rx_genix_config
                            *COM*:0000000c uart_genix_config
                            *COM*:00000008 led
                            *COM*:00000008 button
                            *COM*:00000008 dipswitch_config
                            *COM*:00000018 g_global_handle
                            *COM*:00000014 g_group_handle
                            *COM*:0000000c g_queue_handle
                            *COM*:00000010 g_queue_entry
                            *COM*:00000040 g_channel_handle
                            *COM*:00000010 g_result_handle
                            *COM*:00000008 adc_io
                            *COM*:00000008 relay_KMP
                            *COM*:00000008 relay_KMF
                            *COM*:00000008 relay_KDSG
                            *COM*:00000008 relay_KBAT
                            *COM*:00000008 SLICE0_config
                            *COM*:00000008 SLICE1_config
                            *COM*:00000008 SLICE2_config
                            *COM*:00000006 sysTickParamHandle
                            *COM*:00000004 pcsBmsStatus
                            *COM*:00000008 bmsSensor
                            *COM*:00000008 pcsVoltages
                            *COM*:00000008 pcsCurrents
                            *COM*:00000008 pcsPowers
                            *COM*:00000004 pcsMiscs
                            *COM*:00000005 pcsSystemStatus
                            *COM*:00000004 pcsDCgridStatus
                            *COM*:00000004 pcsACinvStatus
                            *COM*:00000004 pcsPVconvStatus
                            *COM*:00000004 pcsBatconvStatus
                            *COM*:00000050 data_group
                            *COM*:00000004 buffptr
                            *COM*:00000050 espBuffer
                            *COM*:00000008 pduSensorRaw
                            *COM*:00000014 pduSensorAvg
                            *COM*:00000010 pduSensor
                            *COM*:00000008 genix_data
                            *COM*:00000001 mcu_state
                            *COM*:00000006 controlFlag
    {standard input}:113    .text.OP_SetupConnection:00000000 $t
    {standard input}:118    .text.OP_SetupConnection:00000000 OP_SetupConnection
    {standard input}:295    .text.OP_SetupConnection:00000104 $d
    {standard input}:1193   .bss.toggle_timer.10959:00000000 toggle_timer.10959
    {standard input}:301    .text.OP_TurnOnPCS:00000000 $t
    {standard input}:306    .text.OP_TurnOnPCS:00000000 OP_TurnOnPCS
    {standard input}:533    .text.OP_TurnOnPCS:00000154 $d
    {standard input}:1198   .bss.isPrechargeExecuted.10968:00000000 isPrechargeExecuted.10968
    {standard input}:1203   .bss.toggle_timer.10967:00000000 toggle_timer.10967
    {standard input}:540    .text.OP_CheckingPCSStatus:00000000 $t
    {standard input}:545    .text.OP_CheckingPCSStatus:00000000 OP_CheckingPCSStatus
    {standard input}:736    .text.OP_CheckingPCSStatus:0000011c $d
    {standard input}:1208   .bss.isPutToStandbyExecuted.10976:00000000 isPutToStandbyExecuted.10976
    {standard input}:1213   .bss.toggle_timer.10975:00000000 toggle_timer.10975
    {standard input}:743    .text.OP_PutSystemStandby:00000000 $t
    {standard input}:748    .text.OP_PutSystemStandby:00000000 OP_PutSystemStandby
    {standard input}:831    .text.OP_PutSystemStandby:0000006c $d
    {standard input}:1218   .bss.isStandbyExecuted.10983:00000000 isStandbyExecuted.10983
    {standard input}:836    .text.OP_HandlingPCSWarning:00000000 $t
    {standard input}:841    .text.OP_HandlingPCSWarning:00000000 OP_HandlingPCSWarning
    {standard input}:916    .text.OP_PutSystemShutDown:00000000 $t
    {standard input}:921    .text.OP_PutSystemShutDown:00000000 OP_PutSystemShutDown
    {standard input}:1018   .text.OP_CheckingMode:00000000 $t
    {standard input}:1023   .text.OP_CheckingMode:00000000 OP_CheckingMode
    {standard input}:1123   .text.OP_CheckingMode:00000088 $d
    {standard input}:1128   .text.OP_CheckingError:00000000 $t
    {standard input}:1133   .text.OP_CheckingError:00000000 OP_CheckingError
    {standard input}:1194   .bss.toggle_timer.10959:00000000 $d
    {standard input}:1199   .bss.isPrechargeExecuted.10968:00000000 $d
    {standard input}:1204   .bss.toggle_timer.10967:00000000 $d
    {standard input}:1209   .bss.isPutToStandbyExecuted.10976:00000000 $d
    {standard input}:1214   .bss.toggle_timer.10975:00000000 $d
    {standard input}:1219   .bss.isStandbyExecuted.10983:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_fcmpgt
__aeabi_fcmplt
PDU_Switch_Relay
